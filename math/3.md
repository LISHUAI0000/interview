```
3. Digit Counts
Count the number of k's between 0 and n. k can be 0 - 9.
Example
if n = 12, k = 1 in
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

we have FIVE 1's (1, 10, 11, 12)


https://blog.csdn.net/qwe6112071/article/details/72510679
实现思路
这里有两个特别需要注意的地方： 
1. 如果k=0 && n<10 则count=1 
2. 如果k=0,n>=10，则我们应该不算最高位的情况，因为最高位不可能为0，综合以上情况，我们得到下面解法
方法一： Brute Force, 0到n个数挨个算过去。最大的问题就是效率，当n非常大时，就需要很长的运行时间。
方法二：参考http://www.hawstein.com/posts/20.4.html分析一下会发现有如下结论
当某一位的数字小于i时，那么该位出现i的次数为：更高位数字x当前位数
当某一位的数字等于i时，那么该位出现i的次数为：更高位数字x当前位数+低位数字+1
当某一位的数字大于i时，那么该位出现i的次数为：(更高位数字+1)x当前位数

假设一个5位数N=abcde，我们现在来考虑百位上出现2的次数，即，从0到abcde的数中， 有多少个数的百位上是2。分析完它，就可以用同样的方法去计算个位，十位，千位， 万位等各个位上出现2的次数。
当百位c为0时，比如说12013，0到12013中哪些数的百位会出现2？我们从小的数起， 200~299, 1200~1299, 2200~2299, … , 11200~11299, 也就是固定低3位为200~299，然后高位依次从0到11，共12个。再往下12200~12299 已经大于12013，因此不再往下。所以，当百位为0时，百位出现2的次数只由更高位决定， 等于更高位数字(12)x当前位数(100)=1200个。
当百位c为1时，比如说12113。分析同上，并且和上面的情况一模一样。 最大也只能到11200~11299，所以百位出现2的次数也是1200个。
上面两步综合起来，可以得到以下结论：
当某一位的数字小于2时，那么该位出现2的次数为：更高位数字x当前位数

当百位c为2时，比如说12213。那么，我们还是有200~299, 1200~1299, 2200~2299, … , 11200~11299这1200个数，他们的百位为2。但同时，还有一部分12200~12213， 共14个(低位数字+1)。所以，当百位数字为2时， 百位出现2的次数既受高位影响也受低位影响，结论如下：
当某一位的数字等于2时，那么该位出现2的次数为：更高位数字x当前位数+低位数字+1

当百位c大于2时，比如说12313，那么固定低3位为200~299，高位依次可以从0到12， 这一次就把12200~12299也包含了，同时也没低位什么事情。因此出现2的次数是： (更高位数字+1)x当前位数。结论如下：
当某一位的数字大于2时，那么该位出现2的次数为：(更高位数字+1)x当前位数
```
![](https://github.com/only-you/interview/blob/master/picture/3.png)
